]raise )class += ]% }class ,await {>= >> ;?{return ?[while }{
if (:import [await )a0 ]x50 ;)print {]elif (not j22 ]x71 .or ;
assert ^ d27 ?;a19 ,:class a66 (False |= (finally ?while && ;:global {/ [False d32 ?[<< ]
/ ;break * d19 (def ^= ;^= ;True ?+ ))}del )None f6 [y5 :j62 )print ?
{d82 {input (|| {,and *= h29 []-- .print ,]for ;is g87 ?!= }
pass f51 }(pass <= ,.[|= ,input != ;False ./ [elif x6 (with %= ,break {g17 :False ?
;)(if .in -= b71 ];+= ]or g25 :^ [async d40 {input )else + ;/= y32 .True ?
./= not (as {- d1 ?!= i32 )return << )?None [[}k57 ?finally :
.b38 {z64 {try ,raise ]input >= x21 )%= h34 ;)if }]await ;== y65 )continue ++ (;
break >>= j1 })/ [[((False && ;if ?await ?h0 .+ ]return >= ]
def || ,nonlocal *= (*= [print e6 ,! (None > (await ^= x38 ,]?not != g39 ([??
- ?assert <= ;as ;not ;?< (None == :b69 }async * ?:True y21 ?|= (for (
while || def ! .input j86 }input -- [class <= ,return {?return )     ^= ?def [True / .in >> ],if .
     ;from .while |= .pass {+ ??,.False :% ]<<= }raise & ??
:import < .del [:e81 [<< a44 ,* [[def .return e0 }async }assert k10 ,{if h20 (
print )or e78 ?<< g53 ?^ ],f25 .> or ?-= (yield -= (pass != }j72 :== (lambda (
import c40 [continue (y93 ;:== )(>= y96 }[c89 ;in ! y93 ?}True [| ,-= :
- ^ ?elif ++ .;b72 {async x96 {(None *= .&& (k16 ).^ {;global }
~ )def <<= ]/ {]g54 :& x34 )print f11 [del %= x51 ;try [import (from f52 [-= ,
else ?def ,from ;&= ]lambda ?(][as i98 ,-= - in *= a15 ;]
.(nonlocal < .nonlocal > )*= ;if <<= (,nonlocal [else ]^ [finally [lambda }     ^= ,]
not /= {> {*= ?in )~ ]     c90 ((yield ]&= g13 .is -= c6 ?|| y34 .raise b89 )
}.not x28 ?del :;with [/ ;finally ?)++ {continue ?}< )del *= .
! ,)?>= [not e57 {.);| {]def :* )
yield && i74 ?]     [&= ;}nonlocal *= )import {await :async }?b3 ?i13 ,;
class << a3 (.exept .x14 {% b98 ;j42 ,def )[?lambda e17 ){
await && );async )elif {elif >= [*= [>> (None [[global != }def [yield .== 
?await ?-= ,return >> ?(None ;def ?None f41 ?None (.yield :continue {else >> .
return ;|= [elif g47 }for >> [< g86 .a74 ;;[(import (if ^ }
else .?for }+ :! k5 ;== ;y57 ,/ [;[finally :not /= (& e97 :;
[False ]i35 :-- ]<= ?if {input <<= raise && z44 ,[/ ?del ][|= {while .
break c79 [[return c13 ,yield ?(]and ?def .or |= )True == )| )continue {finally ,
;-- .return {x62 ([.]import & e64 }if x75 :     &= .&& {,(
for >> ],c5 }True <= .,f53 {return (lambda }f27 ^ {> b90 )!= .:elif != [
assert ]print ;b68 ;??as [}k13 .>> :a58 ?/ ;None )def ]?
:lambda [! f16 .and )-= (else << )*= y11 ]lambda b31 {;%= ;or .
<<= ,== )not z37 None [;== += )[.x23 ;}.else < d87 :?
else del | ?:for .e36 ,i54 (await != (from [,?exept ],and ?|| y93 ?
! :def ?&& .c30 ,try [<<= k82 ,:is ,with ,     .[-- )in | .
assert || ;<= ]def h44 }~ (def z14 ;with | }is != z6 }import k79 .]+ g75 [<= .[finally h66 (
< ]/= d81 ]from {h6 (| ,lambda ;nonlocal {!= as || e4 }in )*= x92 }assert ^ *= .try ~ [
{f56 (not >> f58 :- }|= ]with >= -- [def ! {continue b45 .;?yield < {pass ;
input }raise )None >= {;with (nonlocal ;?nonlocal && c80 .try ?try }or c96 [
+ ?yield ?^= (True g32 ,print f17 ;[/ :assert ! ,()is ?]nonlocal g18 )
with ^ ;(def ~ ,print h38 ),[+ j52 [-= ;     >> x42 .|= ;is ^= a80 ;>> }^= ]
as + ;[(finally {await }[print g90 {.await [[g97 :?
).input -- ]h61 }?,     d91 ,{k73 (~ }|| c84 ?{async }{
     /= ;x21 [- {++ ]input [b41 },h10 {.as (-= [== (%= x82 {
with e56 }c71 >> ?j82 .e92 ]?]:try % e61 += {not % h10 y56 {
]{x15 (exept & k61 nonlocal {& .b27 )pass << (* ?,lambda ,if && ;elif }
await >= y3 ?-= )not [in | [b99 (<<= e70 ;not * (assert ?if (global (!= ./ [i78 ]
break ?~ }?assert /= {| d49 }<<= ;lambda %= a25 [def && .{.^= f92 ]
.continue )c28 ,:;f82 ;++ z47 {(elif [finally {else ?c79 ;try || d94 }return }
;def / f68 [a71 .from f81 {async c27 .not += {,.else ^= {del }[.:
yield ]((}^= ]?]}]class ]input %= ]continue / x44 }
f44 ]del &= (<< ,.     /= [| }for a47 ),is .pass (await i24 [== )| [<< (
False d5 {]]and g19 ]break b98 ?~ )for ;elif ?[nonlocal ?[;<<= ]
* ]await ,in & :y28 ]assert {try ]:async (continue [-= b37 print ++ :exept c90 :as ! ?
lambda [raise h83 ;yield == :+= ].import k18 :! ;;{{     a90 .(i81 .
;]del == {await .as }! [not b71 :try g48 {?/= h60 ;async )None ,
)[-= [try c91 ]k17 global }class c28 {:++ )[return - .print >>= 
try += ];({[b39 -= c76 )*= try )elif / e45 nonlocal d36 .and ++ k69 while ?del -= :
del ]| [and ,~ b17 ][not ]?- {.and i47 ?>> (/= ,True 
== }|= k93 ^ (as <= .)with ,^= ;class ?if .?print ?
&& ;continue .{* d14 ;< ]|= {,<= f85 [yield :^ ?/ [continue .k5 :
.print != [import (:i78 ]^= };.+= ,^= ?>>= [)raise <= [async :
and ]+ )None ]False async ,]async ,[+= .]:{i1 .
?lambda }.try - .{async + h1 ;is [from :+= {for ??,
[for d28 (-- ,a27 {-- .a83 ]|| }<<= ()or ;not j82 :(for z7 .{
async + ?}h64 .from with += j83 ]     ]del {?.[     [
yield ! :<= .<<= ?/= x24 ]}(+ b7 ][pass e53 (b71 ][[break > (>> ,
del &= ,None [.}del ]:}and i83 ;c78 ,not ]await a31 [while /= (
def [> h38 )raise && }or (def | :> e38 {del y31 )exept ]}def k87 ?not :{z46 [
raise )]}del ~ g85 ,|| x25 ;?global (|| x27 ;?h58 .% [^ ,input ^ e48 .(
c21 ,<= i98 ](- ]finally [| ]]import ?True )lambda {&& ,:]
{yield .{None .< ;finally -= ;is ?{{}]while :await ++ :
>> .import || ;return }nonlocal ;return {not ]?}].:and ^= [yield return &= b93 }
)}g46 ))?class [%= })& c20 [False ]in {True :>>= )
with && .try      ?< [import [global ,async ~ ]raise z16 {and ;c4 {| {True d34 ,assert (
]finally &= ?     x9 );b61 .(}(?with g45 (| e27 ?}else * ,a24 
<= >>= h37 i95 with .>> async >= i43 :and a50 ;with :del ]class % (await &= :^= [assert {x41 .
{else y42 [}}]     ;raise .< )<< )~ }import ,False >= b31 }in [break i54 ?
f32 ]nonlocal (:}as ;class (False z94 :return ;del k24 ?}.:{;
and [,x55 ?<<= .not {h27 ,def ]-= :)^ {]y90 ?or ++ ;
,}pass == .< j70 .(global ::{]def }del ?/= .else }with < [
[}del z45 {assert x32 ?async c21 (*= ;input * :y21 -= :global .[* ?and .++ x59 .
{>>= :g8 ,as ! k97 .* ?finally g87 .{>> ,False :not }break )[?;
,from }:as i70 ]import k78 ]x96 ;:;-= ]raise ][(await [for *= {
nonlocal z76 :]e99 ,+ .> [;.for :< ;j75 ;global [)(False -- (
)~ (<= ]+ ?and y17 })%= {}and b52 .&& :);assert g92 ?& k64 .
in [;from * ;in << )for )b20 ]False f2 [e88 }&& y83 }as ;g91 :,
if .{None (nonlocal ?finally }     ,j38 ::z59 ]b79 .,-- y17 {^ )
[and | [*= )yield >> )> z12 [}await :else [del | ?[:[(,
]+ k93 {with e36 [None |= ]pass [or >>= :None << ?     y19 ::[/= :(with >> :
import .<< ;;> );),::}/ .)g35 ;break f57 ;
(?print &= ):elif << ,from ;(def * }}import .{raise h62 f69 [)
class += ]try a3 ?exept ?k23 }def ! ?y13 )while [False c75 :for (finally [(async [i7 }}
True }>>= ,!= :;&= ?import ,}assert | i11 }elif (False ?class || }finally == {not *= [}
;print j99 ,)in ! (< ]:]|| }&& :}|= [while ,y98 [.
e98 )import :while ()return :.;global != ,.(<= x41 (j73 (* ))
^ ?% ]-= j68 < h89 :def ]};z84 ]class h62 :.class ;{]
[not .return lambda (else ({yield or <<= (b12 (try ~ ,raise e66 {not %= ;assert h18 ]
a24 ]global h51 :&& .()[from (,def %= k39 z93 ),assert ?None [
input + g41 raise * ?<< x28 [{== [del {input -= k87 ;c80 :/= e2 (with g98 :% %= ?for ^= c75 )
;,y59 ?def ,in a53 == b2 ;while )== (else (or .| }raise y3 {]not [
?{def ?[def >= .c86 ?global && .[def ,{?class False / .continue .
in with *= {~ ;yield (+ {/= ,;& ].else >> )pass (}(break ;
.False ;.>= elif <<= [and + j68 ]raise g12 ,break }%= .not .[^= [% ,(
>>= c2 [async :else * != ,;     | )k3 :raise ,is {yield (}{% i80 .continue & (
del {;from != x84 ]&= ?[== c21 .)print *= ]i20 .;>= z55 (-= ]class <= z2 [;
[.while ?or e28 ]break }[]while += [global [try ,lambda ?yield :global 
finally }True <= ?;import ^ d31 ]- ,import ]c29 ]|= }& {&& [input ^ [
/ ;}:/= {! (lambda |= ;async % j26 .~ ,lambda ;and ^ {,* (j68 [}
yield ^= .^ z60 }nonlocal }try ],or %= b25 :!= .or d71 )]async > }> }import /= .x45 if (
(>>= [global ,/ .;+= y12 ]input [;assert < .lambda ]print ?def f24 ?async }
>> ();+ (.& },pass )or )?/= ())input {
|| ::| {?global -= ]*= .import :class ]input [.raise %= c91 ?)finally )
;,::yield ^ e30 :,:)pass ,x79 }:+ d41 ]print -- ]is ++ b4 
*= ?in / )     :{.{(and f35 :^ .as :;from .;
input ?/ });.return [input [a66 ,None );{assert .a25 [
]else .class .;is }< :{raise % }f13 :global == ;continue ++ {for ! ,yield {
raise ,global {not ^ ;,or .finally %= ?:def :| .)return a51 )class += e88 ))
|= return ;from ])def ?> {else % ,{| ][nonlocal [def ~ ;[print y12 
input <<= ;| h76 ,;None ^= b18 [finally }|| ,(async z40 [return h95 (assert [async h32 )True ^= ;* ;
g19 {([{(,     e68 ?await ;{;as + a83 ?-- [<< ,:
+= ?h63 )-= e20 ,input &= i85 ?(for {or ];()+ )False e48 
in .a69 :continue :)not - :False b84 [import (;};
if x17 [i37 )try f74 ,del h50 ;is d20 / ?def -= ;y93 }?in ?global ).for ).
while (exept .)j19 )/ b70 ;>>= d20 ;>> b32 ,True .]True }== ]True }]
yield ?pass h74 + [.}b84 ]exept ^ ,return (print %= g29 (yield z25 :]if ,
else and ?{print }|| ;>= {/ (not ]continue }from [:from ({
break ?& }}* ;lambda )is );}if {c74 ,j4 ;(+ (
is d52 ,await :assert ;(False {yield }print a13 .print ;f55 ]* ])?}and .
e46 ,global /= ,):;exept == z61 ][(?!= .].not *= )
})!= ,and += :,async c16 (;     i49 }del }not > ).None g40 lambda lambda [
for + )input {k67 .with += ?(;input import ]or )del ++ }/ ).f85 ]
def >> >>= /= ;,nonlocal -= ]     }while / :yield {:<<= ?{](elif }
assert i35 :[assert {?)def ^ :{k40 [global e96 (is {global ..% b62 .[
g53 (,&= ;exept (     ;j97 ?or ?pass >> j74 {}?[|| )from - ]/= i90 {
%= (input a74 [async j20 :for g69 :< y99 }elif {== ].{nonlocal ,from ,.while + ,
^= }g61 .*= ?d3 :def | :     > )?f78 .try % .elif :assert & elif )
&= h76 .!= [?[:>= (input << h28 }def - (print }/= h99 ]or i31 ,[pass ;
- )exept (from | z48 }(/ h59 }> x46 ]^= ?input | ,nonlocal ,for {:;}
while .,True ]class ]async ]-= ;e81 ;:continue e90 ?- ,yield <= ,& f39 ?(
,~ ((class ;];]return i16 }raise ;class b43 ]async ,exept ?]
]- ]{== }}?)True e50 {:a23 ;class i4 .import (if ^ ,with != ]
is ;else {/ ?[(* }lambda / (++ ,None [while :;as :
and -= .import .{|| b31 }True elif d0 ;assert }/ [^ b52 }yield ;pass :()
d12 ,raise ]assert .print != :a67 :     ;|| )else (is )del ?{.> h17 [
:)(raise )del > )% .& x55 ,elif }x93 }{break x33 :[;
j9 ((a0 [<= :!= c57 .try while ;! [;a31 ;)?}False .
)break ?raise g47 ]:> d39 await ):in ^ y54 ]None >= d75 print >> []not ]-- a2 }
else -- (e61 :;?++ :return * ..]);del ]in &= ]with || ?< ,
or *= ;assert % [and /= .f15 global %= i82 ;&& x28 :-= )async * :nonlocal || ;input | ;input }[h23 ?h28 .
     }]assert <= j15 :for -= .class {as )import > g59 (not < ().,if :)
}or )z80 [< e12 )a57 [& yield >> [with {;input && f18 {in {..
;:c72 ;|= ,nonlocal ?break ]{global != ;def ;)+ )del :== [global ++ (
return )]elif * [>> j69 :{raise (>>= x53 .try [continue < x38 )z19 /= y75 ;;%= .
try )<<= )]z52 ;% ,.while %= g99 :async <= d11 {]with == ?return ];&= ?global (
^= d74 ,?){* .- ;)e24 )elif k93 (?z35 )?
in x28 :f75 .[b58 }:^= ):}f2 }is != ]yield :async <<= ]++ k46 :)
.class .* )import ?;;a65 import (;+= .try )<= e98 ]continue ;[
if ?! {|| (!= }a39 )await a34 {& (< )+ e56 ,[:elif ~ ;(%= }
     [};x88 ?None || pass >>= e53 ;break /= ]d77 :del [&= ]def .for ?import ]?
~ (break += :{< }<= :.print }break >> ?def :await ]== ]! )!= .
- :]},is < ,(.[yield >>= ??print ,|= (try ^= c99 <<= (
}f67 ([,]% ]| }[j78 :,async / [lambda .async c93 {h84 .
)g72 ,[del y32 )for d64 ]input ^ j11 (..]with >= e19 {,],/ )
yield :<= f64 .break / {&= ,from g33 .< }pass ,> .%= }.global )
:class *= j46 .[exept f5 (* )([:with i26 [print ])from ,,
>> }h38 ;await [e92 or / :^= ]True - ]}as ]finally f49 << )del }.?
class ;)lambda }{or k42 }-- {z53 {-- += z95 .i59 .??}[
;a8 [     .|= {elif y69 [as :async f72 ](&& ;f99 ,&= ,[!= .
[:]print c99 }{await class ;raise ..exept ~ }finally ?b66 }>= i97 ;;
:){from f71 ]g10 .is i16 .;> )return ]].while < ;(break {
or k0 ,from .async :class [finally )*= .{}}& ::}and j73 .
nonlocal < (yield -- ],?False [~ :     ).^= :def ./ }/ d11 ]return ,h47 {
nonlocal :> k5 ;while )f20 ;> ]^= [for < ,while ~ .yield - [h27 }del }<= {break <= (yield /= ;
not ?raise )|| ,./= ]while .<= ]raise != )break in :}:
! {k77 ]print (-- ?print ([&= )del ,False }>> (- d26 {def ,a35 :+ ]
del :}return < )d2 .> [k41 }%= .|= .<= [raise b49 }>>= (None [(
}.{async ^ {]while h8 ,]~ ?y82 (/ ,^= {[[,
:in ! [:?d29 ,global ?}:(-= :global || j92 ),or <<= class ]
}from :! (print [% }>= b1 [- ;{== h71 )j0 .* ).exept >>= ,^ i11 ?
raise &= a3 .global a28 ]>> :,({True + < f63 ?if {& class <= ?,>> ;
[?import d70 .> )% k95 (]input []:++ .lambda *= }++ :! ?e39 
yield }k75 ?{break |= .<<= (from def [x94 {~ input / :| )not )while .]
:h55 (++ .&& (?not |= x66 }++ ]~ j55 {-= {and c54 ?% e10 :continue class )
% .in i79 [{as a56 [break {){i50 .((and }nonlocal ,>= h74 (None ^ (
,??== [>>= ?k15 }False }(+= {del == ?nonlocal + )True ;input ?
++ j12 }None ?>>= [{from (].pass ,>> {}/= ,{not c32 )is x79 ;
elif x9 )]del (>>= },([}:in - ]assert [{del ;
== ,c95 .continue / {from -= ?.d71 >>= ,z59 .lambda * .in ,None ).| ).
in (;,try f14 (;}None | ;assert ;else && ?for == d97 ,.> ,finally ^ ]
(,import )[[{,[await .and [True -- (def }~ ;pass j79 ;
?&& (!= {;i79 .print :is b6 ;%= ,;elif ;del (! {<<= e95 ,&& (
&= {or % )import [True >> }async ?(>> ]>= [finally <<= ,^= ,& x15 ?<= a33 (lambda {
await j51 :+= z1 ?     %= )yield (return ]from :<<= e94 {print | ;f52 ;)((& }for [
False {async {,(nonlocal e44 :)pass ]{False ({yield :)])
global ()^= ,a47 ,| (~ .[()/ }x50 :.<= .
.elif ,,is ]class }global * .!= ;exept .import != )lambda {.     :
;f2 ?,]h56 )|| yield /= ;~ :finally ?or ?y69 )
del ^= :/= [i90 .print ?from > ,^= ,break k65 }[x33 ];False ;~ ]& .
^= ;nonlocal ::pass ~ ;x81 class -- ;)(def ,and || :?]a85 ;- c11 {
try && ]input )?<= }<= :print x46 )class + ]class f77 async || .with ][;:]
(as :with ?True % {g60 ){continue -= ]:raise [while [pass [await .continue || ]nonlocal 
*= .class )nonlocal .and ])^= };k94 {;pass {;finally ^= ?False y86 :* {
{i63 )[import (?}[)global << % )&= c1 ;.}
lambda ;def ?(elif [     |= }return (continue a47 (None ;,del ;elif (i5 ;or * [
.yield ()print [[]def }:from i91 ,,j91 )async & {}
not k61 ?]- ?*= ,await &= []/= }c41 ,}& }False e1 )lambda (>= .
as .{^ )not {?.?},[     :&= b22 ]
if and <<= z46 ,{break }g44 )True ]>>= (yield |= [++ ?import :)[return %= );
yield :raise d20 {/ :::>>= (!= };from }?)?^ .
-= :async }assert && ,not ?:for k13 {a52 )-- (else y94 ,]finally ?[raise [j8 {
exept != .;return + << ,][,>> h34 ;def > }[or ]continue += k43 ?<< 
.! ;:(}yield )| )try ;,(finally or += ?exept }c48 }
if {a23 ;* ;:)pass e46 .     )| }b53 ,f79 ]|= (print c50 (
async :from ?[import (- (break :> ,y77 :.import .== / ]for != ;]
.%= .}def (import }h49 else {>= {[]from ^ [,del |= }
)?< :print .^ e34 :elif ?{[a8 }*= ,(continue a15 ,;
/= ;lambda :break :{,pass ?;!= (?if * ,- ]finally ^= != {
* ,None %= ()is )return a67 ]as d43 {),}def -= ,for | :input [k80 :from [
exept < )elif (await [;global ?def }import :or / :h78 ?:.from &= ].print :
finally ).^ h64 (and / e16 [== (]<= h47 ;<= }pass (global :await ~ e54 (((
}(,],c47 )}({:?global ?(k21 }
def g31 }yield + {([try -- d14 {&= :while (]input :f50 if ;~ }+= {nonlocal ;
try ..(import ?elif ],return h66 }>> j96 >>= (,as j18 (,{
[)     {>>= ).?;not ?nonlocal lambda || a65 :assert *= .
async |= x16 ?z35 .k54 c11 (!= )from }print <<= }]>> -- (None ?}global ,
< {;-= )True % d68 }% ;]in :i5 (True ! [return ){[await [j68 
& :}.~ e94 {not .|= [;]class %= [from >>= [h99 .>>= ,,?
~ {await j89 ]+= h39 }     ..as ^= ,async ,^= [True .<<= ;]pass || e11 }print :input .
!= d17 (as }yield (:*= (,?}b43 ;[not :if (in h53 ]nonlocal )
+= (if || a87 ]while & .)((+= {exept :input <<= ?in -= ]| z81 {|= (h78 (
x31 ]}{is x54 ;as ?with .}or :>> .! ?input g29 {finally [a53 )with < k48 )
;class in }-- ,exept |= .^ [(else ?]&= [raise ,[?{
e75 ;,% .}pass ~ [<<= ./ ,if {False == }>>= c18 ! }?~ ,try 
>>= (?finally == ]j39 [False ]async ,elif .assert )(<< ?,<< ;from f81 ]input && }
from y74 ]:.{,! .else e31 {def .x81 :)-= .del ;^= ,
;if k70 ;.|| ;(elif < }/= ,}}and ]?)yield :
:({% (await / ,h25 .while (/= .[j44 :f90 ;;break || ]try | ]
break {elif ]y92 (or % ;def d30 }as ! :,await %= ?for (else :False -= j41 )raise ;c67 )
for [import || .del >= ;{from )(& in ,&= )/= h50 :with [{];
global == ;async [^= ,}and b36 {input ~ .def yield .g65 {;-= ;k75 )import -= ]?
?assert e29 (.-- ,in |= ?is b11 while :;;:e29 ?h80 }with (while k23 :
< .del == }]raise &= )(!= })]{input x23 .global == [>= .def >> y33 ;<= )
with >= ):* (def |= k72 {class &= ]| .assert :!= ;,async <= {f42 )del )[
|| ({break ]     ++ )]{]?and ]None )break z68 .+ y56 }&= ,)
{&= [raise z0 ,:is (else g32 ;%= :!= (++ ;]del |= c41 .)exept a80 :is ]
assert ?.{or :     []True y76 :[def | y86 ?:).)(
{True |= {;as :|| f56 :.]del :     z95 ];print k45 [.}
;assert a97 (]class ?++ c3 ! || .?:>= }-= (f32 )nonlocal :
}* k3 [pass [try ^ c75 ;lambda ^= }:continue ?lambda [,?:(},
}?try }>>= :if }]def {;],:>> ,{g81 ;
def }def &= ?yield / }x34 ,{:|| {f90 ]&= a0 [and ?is b48 .)<< g98 )(
continue |= (as c58 (,;| i83 ;&= h37 .global ?]not x74 ?def ?pass ~ ;(while >>= f86 ),
class [(%= .)/= a19 break f59 {print {as pass ++ ,.^= {[- ?
(elif (del g7 }for [exept e16 )i80 ]print ++ }is ^= [}/ [False ^ {;(with <<= {
?[.c73 ;async )*= {{z6 {lambda :pass }     g68 {async :}True [
k10 ++ ;!= {while )exept z93 ,d54 ?global - (input :?yield z89 }<<= :assert | ?d43 [async || [
.- :(| ;);input ]try y67 ;a76 {break (await :&& {try .def c9 ?
)yield });z81 {,-= (>>= [return e53 .-= ]input [?nonlocal * c38 > ,
with / }False &= ,/= j69 (- b15 :global >= async %= y69 (with for + :== ,i24 (elif + :
< :try }while >>= }:|= (;not x79 (.)]def >> z16 .def i10 ?+= c97 )
import e91 {{+= .(,:?in }elif ?== )>>= :.exept })
:/ ?*= ]in c83 )await += ,>>= class ,[for [async || ?assert .else :)
global }(d68 :exept ,     ]b26 ;,True |= ;not (exept {{== ..nonlocal .
continue * b34 [^ i25 {% ?while &= .{+ x28 )if .[{! >= ,a46 (%= 
g75 ;{await .not ?assert | )while |= [nonlocal }& ,;await >>= .&= z50 .+ ]in >> (
x82 [break }if )and ?;assert ;j91 }raise from {print [:,finally :,
{finally try f62 }class << )&= class ;global c94 );&& i99 ([elif a33 ?> (continue .)
nonlocal >> ;-- f93 :;with )del >> .?:*= [return ?[[k32 ;not ! [
async [finally ^= }].e20 :lambda finally {<< )+= ]>= ?:<= .def .
^ [while k4 [else }*= {{>> .?class [-= {(True i59 :++ (
c40 )if :! (import ,[]or [exept [elif :>= ,del ]&= :)
as .> if ;nonlocal ]]h15 ;?(else ++ :!= .try ]     (;%= 
^ )% ;break (or [*= ]from {;>>= ?     .)^ (try ,~ 
;if == [not ?< ?d83 (is :False h2 (;|= .^ ;finally ?while + a68 b26 ]% k93 
|= ?e99 ;     i69 ;lambda - .,raise ?with }is ++ g16 )elif ?with )-= z54 ]>> continue {
await a19 ?&& ]++ ]finally ]a90 (< ?< {| [import {class {a42 }input += c74 {%= k46 ]
raise ,def << }with |= ;()g75 ]&= }k19 ! a32 :     ;|= c68 ]/ {)
break ?not &= f52 )<< ,,def ]True h71 ;return ;<<= c70 :?a20 ,h55 ?^= ]
,None {raise );input -= (:{+= [if (h11 &= [&= .as + g47 ]! [
!= .c72 )pass -= e19 ,- >>= (,None ,del ;finally ?;from (class }>= .{
elif ~ ::[[);- (^ ]assert & }as >= d92 }def }class + ;def [(
try ;+ .%= :)global ]not ;assert ?as ,finally ^= ;else (.;:
lambda != k59 (import .not / {,await }with [+= .not [assert y64 {exept != .exept ;while ;)raise }
)~ ;* .<<= ;.::assert .::a25 ];>= z61 .]
.(True ,x71 ?False <= [):class || a1 .i11 )break ++ :exept ;)break )
/= })finally i20 [* )> .)]:nonlocal i81 )assert ^= :.(& ?from }
]{,i9 ;~ del e55 :-- ]break / .! )[}class z75 ?if ^ )
lambda [def {and ^ k67 ]print |= (== ,}[y53 ,break < ,]| f26 {[c56 ?False ^ y18 ;
for }e69 }:,:^= c65 .?as )> ?input )e67 :nonlocal ,if * ]
lambda :True z57 (]None [;?{(exept {>>= ,]],
False .g66 [< continue -- g37 (f3 {/ (?{;def ]pass || {:finally ]
lambda ~ {async }.[*= :<< :if >>= :False a54 [,print d78 )as )* }.
k8 .async [;>> .i40 ,?+= .* {|| .lambda ;from ;+ {while * .async }
raise (>= b16 ;}% }(|= ,from [)k78 ]print %= :;x85 ,++ ;
input ]async *= (?)?{>= elif :([     ,del g60 :{?
async )await :pass ,;!= ]from ,,}]+ b7 ;][:pass -- ,
in ;;b49 ,d95 ,global i18 [not f97 [+ ?,raise }]global []}++ ?
%= x7 :is ?True ;print && is .]>> ;def != ,yield ]+ [f45 :     <= g38 (lambda -= h40 (/= ,
e61 ;with ++ ?pass :is ~ x0 [-= }y85 ;:d2 from }}c10 :;< }
False .lambda )){{True (}def {(z38 ,* )True != ({)
z48 {.> (pass (;nonlocal >>= :]j31 ,y65 }+= x5 ]yield >= d79 };)in }
print >= [while ,False - }return z53 ?None :lambda ! a84 .:not [assert k8 [)None )+ :
while }-= ;None }and h86 .def e57 ])global {def != ({++ ,:,raise *= ,.
